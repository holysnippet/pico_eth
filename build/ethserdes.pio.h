// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// eth_ser //
// ------- //

#define eth_ser_wrap_target 2
#define eth_ser_wrap 2

static const uint16_t eth_ser_program_instructions[] = {
    0xf702, //  0: set    pins, 2                [23]
    0xeb02, //  1: set    pins, 2                [11]
            //     .wrap_target
    0xe000, //  2: set    pins, 0                    
            //     .wrap
    0xe502, //  3: set    pins, 2                [5] 
    0xe201, //  4: set    pins, 1                [2] 
    0x00e7, //  5: jmp    !osre, 7                   
    0x0000, //  6: jmp    0                          
    0x6021, //  7: out    x, 1                       
    0x0023, //  8: jmp    !x, 3                      
    0xe501, //  9: set    pins, 1                [5] 
    0xe102, // 10: set    pins, 2                [1] 
    0x0005, // 11: jmp    5                          
};

#if !PICO_NO_HARDWARE
static const struct pio_program eth_ser_program = {
    .instructions = eth_ser_program_instructions,
    .length = 12,
    .origin = -1,
};

static inline pio_sm_config eth_ser_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + eth_ser_wrap_target, offset + eth_ser_wrap);
    return c;
}
#endif

// ------- //
// eth_det //
// ------- //

#define eth_det_wrap_target 3
#define eth_det_wrap 14

static const uint16_t eth_det_program_instructions[] = {
    0xc004, //  0: irq    nowait 4                   
    0xc020, //  1: irq    wait 0                     
    0x2020, //  2: wait   0 pin, 0                   
            //     .wrap_target
    0x4401, //  3: in     pins, 1                [4] 
    0xa026, //  4: mov    x, isr                     
    0x00ad, //  5: jmp    x != y, 13                 
    0xa342, //  6: nop                           [3] 
    0xc044, //  7: irq    clear 4                    
    0xe029, //  8: set    x, 9                       
    0x00cb, //  9: jmp    pin, 11                    
    0x0008, // 10: jmp    8                          
    0x0049, // 11: jmp    x--, 9                     
    0x0000, // 12: jmp    0                          
    0x00c2, // 13: jmp    pin, 2                     
    0x20a0, // 14: wait   1 pin, 0                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program eth_det_program = {
    .instructions = eth_det_program_instructions,
    .length = 15,
    .origin = -1,
};

static inline pio_sm_config eth_det_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + eth_det_wrap_target, offset + eth_det_wrap);
    return c;
}
#endif

// ------- //
// eth_des //
// ------- //

#define eth_des_wrap_target 1
#define eth_des_wrap 4

static const uint16_t eth_des_program_instructions[] = {
    0x2020, //  0: wait   0 pin, 0                   
            //     .wrap_target
    0x2044, //  1: wait   0 irq, 4                   
    0x4601, //  2: in     pins, 1                [6] 
    0x00c0, //  3: jmp    pin, 0                     
    0x20a0, //  4: wait   1 pin, 0                   
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program eth_des_program = {
    .instructions = eth_des_program_instructions,
    .length = 5,
    .origin = -1,
};

static inline pio_sm_config eth_des_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + eth_des_wrap_target, offset + eth_des_wrap);
    return c;
}

    #include "hardware/clocks.h"
    static void pio_set_y(PIO pio, uint sm, uint32_t v)
    {
        const uint instr_shift = pio_encode_in(pio_y, 4);
        const uint instr_mov = pio_encode_mov(pio_y, pio_isr);
        for (int i = 7; i >= 0; i--)
        {
            const uint32_t nibble = (v >> (i * 4)) & 0xf;
            pio_sm_exec(pio, sm, pio_encode_set(pio_y, nibble));
            pio_sm_exec(pio, sm, instr_shift);
        }
        pio_sm_exec(pio, sm, instr_mov);
    }
    static void pio_set_x(PIO pio, uint sm, uint32_t v)
    {
        const uint instr_shift = pio_encode_in(pio_x, 4);
        const uint instr_mov = pio_encode_mov(pio_x, pio_isr);
        for (int i = 7; i >= 0; i--)
        {
            const uint32_t nibble = (v >> (i * 4)) & 0xf;
            pio_sm_exec(pio, sm, pio_encode_set(pio_x, nibble));
            pio_sm_exec(pio, sm, instr_shift);
        }
        pio_sm_exec(pio, sm, instr_mov);
    }
    static inline void eth_des_program_init(PIO pio, uint sm, uint offset, uint data_pin)
    {
        pio_sm_config sm_config = eth_des_program_get_default_config(offset);
        pio_sm_set_pindirs_with_mask(pio, sm, 0u, 1u << data_pin);
        sm_config_set_in_pins(&sm_config, data_pin);
        sm_config_set_jmp_pin(&sm_config, data_pin);
        sm_config_set_in_shift(&sm_config, true, true, 8);
        sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_RX);
        sm_config_set_clkdiv(&sm_config, 1.0f);
        pio_gpio_init(pio, data_pin);
        pio_sm_init(pio, sm, offset + 0x01, &sm_config);
        pio_sm_exec(pio, sm, pio_encode_irq_set(false, 4));
    }
    static inline void eth_ser_program_init(PIO pio, uint sm, uint offset, uint pin_tx)
    {
        pio_sm_config c = eth_ser_program_get_default_config(offset);
        pio_sm_set_pins_with_mask(pio, sm, 0u, 3u << pin_tx);
        pio_sm_set_pindirs_with_mask(pio, sm, ~0u, 3u << pin_tx);
        sm_config_set_set_pins(&c, pin_tx, 2);
        sm_config_set_out_shift(&c, true, true, 8);
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
        sm_config_set_clkdiv(&c, 1.0);
        pio_gpio_init(pio, pin_tx);
        pio_gpio_init(pio, pin_tx + 1);
        // gpio_set_drive_strength(pin_tx, GPIO_DRIVE_STRENGTH_12MA);
        // gpio_set_slew_rate(pin_tx, GPIO_SLEW_RATE_FAST);
        // gpio_set_drive_strength(pin_tx + 1, GPIO_DRIVE_STRENGTH_12MA);
        // gpio_set_slew_rate(pin_tx + 1, GPIO_SLEW_RATE_FAST);
        pio_sm_init(pio, sm, offset + 0x02, &c);
    }
    static inline void eth_det_program_init(PIO pio, uint sm, uint offset, uint data_pin) {
        pio_sm_config sm_config = eth_det_program_get_default_config(offset);
        pio_sm_set_pindirs_with_mask(pio, sm, 0u, 1u << data_pin);
        sm_config_set_in_pins(&sm_config, data_pin);
        sm_config_set_jmp_pin(&sm_config, data_pin);
        sm_config_set_in_shift(&sm_config, true, false, 32);
        sm_config_set_clkdiv(&sm_config, 1.0f);
        pio_gpio_init(pio, data_pin);
        pio_sm_init(pio, sm, offset + 0x02, &sm_config);
        pio_set_y(pio, sm, 0x5555555D);
    }
    static void pio_jump_nlp(PIO pio, uint sm, uint offset)
    {
        const uint instr_eth_nlp = pio_encode_jmp(offset + 0x01);
        pio_sm_exec(pio, sm, instr_eth_nlp);
    }

#endif

